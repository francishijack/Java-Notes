# 复杂度分析

$$
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$


## 时间复杂度

[如何分析算法的*时间复杂度*](https://zhuanlan.zhihu.com/p/362067969)

### 加法法则：

复杂度表示方法只是关注代码执行时间随数据规模增长的变化趋势。通常会忽略掉常数项、低阶项、系数项，只保留==最高阶项==. 
**总的时间复杂度等于量级最大的那段代码的时间复杂度**

> 常量复杂度 $O(1)$：一段代码执行 100 次、1,000 次、10,000 次，只要是个已知的数值，和 $n$ 无关.

若代码具有多个变量，其复杂度由多个数据的规模来决定，例如 $m$ 和 $n$. 那么，我们可以将复杂度表示为 $O(m+n)$，$O(m*n)$，$O(m^2+n)$，$O(m^2+n^2)$，$O(m*n^2)$ 等等。

### 乘法法则：

- 如果 $T_1(n)=O(f(n))$, $T_2(n)=(g(n))$，那么 $T(n)=T_1(n) \times T_2(n)=O(f(n) \times g(n))$

**嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

### 对数阶复杂度

```
let i = 1
while (i <= n) {
    i = i * 2
}
```

第三行代码被执行了多少次？
输入变量是 $n$，假设执行了 $x$ 次，那么 $2^x=n$，那么 $x=log_2n$，所以这段代码的时间复杂度就是 $O(log_2n)$.

而实际上，所有的对数阶时间复杂度都可以用 $O(logn)$ 来表示，因为对数之间可以相互转换：

$$
log_3(n)=\frac{log_2(n)}{log_2(3)}=O(log_2n)
$$

如果一段代码的时间复杂度是 $O(logn)$，我们循环执行 $n$ 遍，时间复杂度就是 $O(nlogn)$ 了。而且，$O(nlogn)$ 也是一种非常常见的算法时间复杂度。比如，**归并排序、快速排序**的时间复杂度都是 $O(nlogn)$.

> 一般情况下，要想成为 $log$ 时间复杂度，要么是与二叉树相关，要么是与二分查找有关.


## 空间复杂度

常量的存储空间可忽略不计，只考虑变量的存储空间大小.

```
void print(int n) {
    int i = 0;
    int[] a = new int[n];
    for (i; i <n; ++i) {
        a[i] = i * i;
    }

    for (i = n-1; i >= 0; --i) {
        print out a[i]
    }
}
```

存储了大小为 $n$ 的数组，因此，整段代码的空间复杂度为 $O(n)$.

我们常见的空间复杂度就是 $O(1)、O(n)、O(n^2)$，像 $O(logn)$、$O(nlogn)$ 这样的对数阶复杂度平时都用不到.

